use std::ffi::{CStr, CString};

use libc;

use ::{ffi, FromRaw, AsRaw, Userdata, Libinput, Seat, TabletPadModeGroup};

/// Capabilities on a device.
///
/// A device may have one or more capabilities at a time, capabilities
/// remain static for the lifetime of the device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DeviceCapability
{
    /// Keyboard capability
    Keyboard,
    /// Pointer capability
    Pointer,
    /// Touch capability
    Touch,
    /// TabletTool capability
    TabletTool,
    /// TabletPad capability
    TabletPad,
    /// Gesture capability
    Gesture,
    /// Switch capability
    Switch,
}

/// Pointer Acceleration Profile
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AccelProfile
{
    /// A flat acceleration profile.
    ///
    /// Pointer motion is accelerated by a constant (device-specific)
    /// factor, depending on the current speed.
    Flat,
    /// An adaptive acceleration profile.
    ///
    /// Pointer acceleration depends on the input speed. This is the
    /// default profile for most devices.
    Adaptive,
}

/// The click method defines when to generate software-emulated
/// buttons, usually on a device that does not have a specific
/// physical button available.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ClickMethod
{
    /// Use software-button areas (see [Clickfinger behavior](https://wayland.freedesktop.org/libinput/doc/latest/clickpad_softbuttons.html#clickfinger))
    /// to generate button events.
    ButtonAreas,
    /// The number of fingers decides which button press to generate.
    Clickfinger,
}

/// The scroll method of a device selects when to generate scroll axis
/// events instead of pointer motion events.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ScrollMethod
{
    /// Never send scroll events instead of pointer motion events.
    ///
    /// This has no effect on events generated by scroll wheels.
    NoScroll,
    /// Send scroll events when two fingers are logically down on the
    /// device.
    TwoFinger,
    /// Send scroll events when a finger moves along the bottom or
    /// right edge of a device.
    Edge,
    /// Send scroll events when a button is down and the device moves
    /// along a scroll-capable axis.
    OnButtonDown,
}

/// Errors returned when applying configuration settings.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DeviceConfigError {
    /// Configuration not available on this device.
    Unsupported,
    /// Invalid parameter range.
    Invalid,
}

/// The send-event mode of a device defines when a device may generate
/// events and pass those events to the caller.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SendEventsMode {
    /// Send events from this device normally.
    ///
    /// This is a placeholder mode only, any device detected by
    /// libinput can be enabled. Do not test for this value as bitmask.
    Enabled,
    /// Do not send events through this device.
    ///
    /// Depending on the device, this may close all file descriptors
    /// on the device or it may leave the file descriptors open and
    /// route events through a different device.
    ///
    /// If this mode is set, other disable modes may be ignored.
    /// For example, if both `Disabled` and `DisabledOnExternalMouse`
    /// are set, the device remains disabled when all external pointer
    /// devices are unplugged.
    Disabled,
    /// If an external pointer device is plugged in, do not send
    /// events from this device.
    ///
    /// This option may be available on built-in touchpads.
    DisabledOnExternalMouse,
}

/// Map 1/2/3 finger tips to buttons
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TapButtonMap {
    /// 1/2/3 finger tap maps to left/right/middle
    LeftRightMiddle,
    /// 1/2/3 finger tap maps to left/middle/right
    LeftMiddleRight,
}

/// Result returned when applying configuration settings.
pub type DeviceConfigResult = Result<(), DeviceConfigError>;

/// Mask reflecting LEDs on a device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Led {
    /// Num Lock Led
    NumLock,
    /// Caps Lock Led
    CapsLock,
    /// Scroll Lock Led
    ScrollLock,
}

ffi_ref_struct!(
/// Device group
///
/// Some physical devices like graphics tablets are represented by
/// multiple kernel devices and thus by multiple `Device`s.
///
/// libinput assigns these devices to the same `DeviceGroup` allowing
/// the caller to identify such devices and adjust configuration
/// settings accordingly. For example, setting a tablet to left-handed
/// often means turning it upside down. A touch device on the same
/// tablet would need to be turned upside down too to work correctly.
///
/// All devices are part of a device group though for most devices the
/// group will be a singleton. A device is assigned to a device group
/// on `DeviceAddedEvent` and removed from that group on
/// `DeviceRemovedEvent`. It is up to the caller to track how many
/// devices are in each device group.
///
/// Device groups do not get re-used once the last device in the group
/// was removed, i.e. unplugging and re-plugging a physical device
/// with grouped devices will return a different device group after
/// every unplug.
///
/// Device groups are assigned based on the LIBINPUT_DEVICE_GROUP udev
/// property, see [Static device configuration](https://wayland.freedesktop.org/libinput/doc/latest/udev_config.html) via udev.
struct DeviceGroup, ffi::libinput_device_group, ffi::libinput_device_group_ref, ffi::libinput_device_group_unref, ffi::libinput_device_group_get_user_data, ffi::libinput_device_group_set_user_data);

ffi_ref_struct!(
/// Representation of a single input device as seen by the kernel.
///
/// A single physical device might consist out of multiple input
/// devices like a keyboard-touchpad combination. See `DeviceGroup`
/// if you want to track such combined physical devices.
struct Device, ffi::libinput_device, ffi::libinput_device_ref, ffi::libinput_device_unref, ffi::libinput_device_get_user_data, ffi::libinput_device_set_user_data);

impl Device {
    /// Get the libinput context from the device.
    pub fn context(&self) -> Libinput
    {
        unsafe {
            Libinput::from_raw(ffi::libinput_device_get_context(self.as_raw_mut()))
        }
    }

    /// Get the device group this device is assigned to.
    ///
    /// Some physical devices like graphics tablets are represented by
    /// multiple kernel devices and thus by multiple `Device`s.
    ///
    /// libinput assigns these devices to the same `DeviceGroup`
    /// allowing the caller to identify such devices and adjust
    /// configuration settings accordingly. For example, setting a
    /// tablet to left-handed often means turning it upside down. A
    /// touch device on the same tablet would need to be turned upside
    /// down too to work correctly.
    ///
    /// All devices are part of a device group though for most devices
    /// the group will be a singleton. A device is assigned to a
    /// device group on `DeviceAddedEvent` and removed from that group
    /// on `DeviceRemovedEvent`. It is up to the caller to track how
    /// many devices are in each device group.
    ///
    /// Device groups do not get re-used once the last device in the
    /// group was removed, i.e. unplugging and re-plugging a physical
    /// device with grouped devices will return a different device
    /// group after every unplug.
    ///
    /// Device groups are assigned based on the `LIBINPUT_DEVICE_GROUP`
    /// udev property, see [Static device configuration](https://wayland.freedesktop.org/libinput/doc/latest/udev_config.html) via udev.
    pub fn device_group(&self) -> DeviceGroup
    {
        unsafe {
            DeviceGroup::from_raw(ffi::libinput_device_get_device_group(self.as_raw_mut()))
        }
    }

    /// Get the system name of the device.
    ///
    /// To get the descriptive device name, use `name`.
    pub fn sysname(&self) -> &str
    {
        unsafe {
            CStr::from_ptr(ffi::libinput_device_get_sysname(self.as_raw_mut()) ).to_str().expect("Device sysname is no valid utf8")
        }
    }

    /// The descriptive device name as advertised by the kernel and/or
    /// the hardware itself.
    ///
    /// To get the sysname for this device, use `sysname`.
    pub fn name(&self) -> &str
    {
        unsafe {
            CStr::from_ptr(ffi::libinput_device_get_name(self.as_raw_mut()) ).to_str().expect("Device name is no valid utf8")
        }
    }

    /// A device may be mapped to a single output, or all available
    /// outputs.
    ///
    /// If a device is mapped to a single output only, a relative
    /// device may not move beyond the boundaries of this output. An
    /// absolute device has its input coordinates mapped to the
    /// extents of this output.
    pub fn output_name(&self) -> Option<&str>
    {
        unsafe {
            let ptr = ffi::libinput_device_get_output_name(self.as_raw_mut());
            if !ptr.is_null() {
                Some(CStr::from_ptr(ptr).to_str().expect("Device output_name is no valid utf8"))
            } else {
                None
            }
        }
    }

    ffi_func!(
    /// Get the product ID for this device.
    pub fn id_product, ffi::libinput_device_get_id_product, u32);
    ffi_func!(
    /// Get the vendor ID for this device.
    pub fn id_vendor, ffi::libinput_device_get_id_product, u32);

    /// Get the seat associated with this input device, see
    /// [Seats](https://wayland.freedesktop.org/libinput/doc/latest/seats.html)
    /// for details.
    ///
    /// A seat can be uniquely identified by the physical and logical
    /// seat name. There will ever be only one seat instance with a
    /// given physical and logical seat name pair at any given time,
    /// but if no external reference is kept, it may be destroyed if
    /// no device belonging to it is left.
    pub fn seat(&self) -> Seat
    {
        unsafe {
            Seat::from_raw(ffi::libinput_device_get_seat(self.as_raw_mut()))
        }
    }

    /// Change the logical seat associated with this device by removing the device and adding it to the new seat.
    ///
    /// This command is identical to physically unplugging the device,
    /// then re-plugging it as a member of the new seat. libinput will
    /// generate a `DeviceRemovedEvent` event and this `Device` is
    /// considered removed from the context; it will not generate
    /// further events and will be freed when it goes out of scope.
    /// A `DeviceAddedEvent` event is generated with a new `Device`
    /// handle. It is the caller's responsibility to update references
    /// to the new device accordingly.
    ///
    /// If the logical seat name already exists in the device's
    /// physical seat, the device is added to this seat. Otherwise, a
    /// new seat is created.
    ///
    /// ## Note
    /// This change applies to this device until removal or `suspend`,
    /// whichever happens earlier.
    pub fn set_seat_logical_name(&mut self, name: &str) -> Result<(), ()>
    {
        let name = CString::new(name).expect("New logical_seat name contained a null-byte");
        unsafe {
            if ffi::libinput_device_set_seat_logical_name(self.as_raw_mut(), name.as_ptr()) == 0 {
                Ok(())
            } else {
                Err(())
            }
        }
    }

    ffi_func!(
    /// Return a udev handle to the device that is this libinput
    /// device, if any.
    ///
    /// The returned handle has a refcount of at least 1, the caller
    /// must call `udev_device_unref()`` once to release the
    /// associated resources. See the
    /// [libudev documentation](http://www.freedesktop.org/software/systemd/libudev/)
    /// for details.
    ///
    /// Some devices may not have a udev device, or the udev device
    /// may be unobtainable. This function returns NULL if no udev
    /// device was available.
    ///
    /// Calling this function multiple times for the same device may
    /// not return the same udev handle each time.
    pub fn udev_device, ffi::libinput_device_get_udev_device, *mut libc::c_void);

    /// Update the LEDs on the device, if any.
    ///
    /// If the device does not have LEDs, or does not have one or more
    /// of the LEDs given in the mask, this function does nothing.
    ///
    /// ## Arguments
    ///
    /// leds: Leds to turn on
    ///
    /// Missing `Led`s will be turned off.
    /// The slice is interpreted as a bitmap.
    pub fn led_update(&mut self, leds: &[Led]) {
        let mut bitmask = 0u32;
        for led in leds {
            match *led {
                Led::NumLock => bitmask |= ffi::libinput_led_LIBINPUT_LED_NUM_LOCK,
                Led::CapsLock => bitmask |= ffi::libinput_led_LIBINPUT_LED_CAPS_LOCK,
                Led::ScrollLock => bitmask |= ffi::libinput_led_LIBINPUT_LED_SCROLL_LOCK,
            }
        }
        unsafe {
            ffi::libinput_device_led_update(self.as_raw_mut(), bitmask)
        }
    }

    /// Check if the given device has the specified capability.
    pub fn has_capability(&self, cap: DeviceCapability) -> bool
    {
        unsafe { ffi::libinput_device_has_capability(self.as_raw_mut(), match cap {
            DeviceCapability::Keyboard => ffi::libinput_device_capability::LIBINPUT_DEVICE_CAP_KEYBOARD,
            DeviceCapability::Pointer => ffi::libinput_device_capability::LIBINPUT_DEVICE_CAP_POINTER,
            DeviceCapability::Touch => ffi::libinput_device_capability::LIBINPUT_DEVICE_CAP_TOUCH,
            DeviceCapability::TabletTool => ffi::libinput_device_capability::LIBINPUT_DEVICE_CAP_TABLET_TOOL,
            DeviceCapability::TabletPad => ffi::libinput_device_capability::LIBINPUT_DEVICE_CAP_TABLET_PAD,
            DeviceCapability::Gesture => ffi::libinput_device_capability::LIBINPUT_DEVICE_CAP_GESTURE,
            DeviceCapability::Switch => ffi::libinput_device_capability::LIBINPUT_DEVICE_CAP_SWITCH,
        }) != 0 }
    }

    /// Get the physical size of a device in mm, where meaningful.
    ///
    /// This function only succeeds on devices with the required data,
    /// i.e. tablets, touchpads and touchscreens.
    pub fn size(&self) -> Option<(f64, f64)>
    {
        let mut width = 0.0;
        let mut height = 0.0;

        match unsafe { ffi::libinput_device_get_size(self.as_raw_mut(), &mut width as *mut _, &mut height as *mut _) } {
            0 => Some((width, height)),
            _ => None,
        }
    }

    /// Check if a `DeviceCapability::Pointer` device has a button
    /// with the given code (see linux/input.h).
    pub fn pointer_has_button(&self, button: u32) -> Result<bool, ()>
    {
        match unsafe { ffi::libinput_device_pointer_has_button(self.as_raw_mut(), button) } {
            1 => Ok(true),
            0 => Ok(false),
            -1 => Err(()),
            _ => unreachable!(),
        }
    }

    /// Check if a `DeviceCapability::Keyboard` device has a key with
    /// the given code (see linux/input.h).
    pub fn keyboard_has_key(&self, key: u32) -> Result<bool, ()>
    {
        match unsafe { ffi::libinput_device_keyboard_has_key(self.as_raw_mut(), key) } {
            1 => Ok(true),
            0 => Ok(false),
            -1 => Err(()),
            _ => unreachable!(),
        }
    }

    ffi_func!(
    /// Return the number of buttons on a device with the
    /// `DeviceCapability::TabletPad` capability.
    ///
    /// Buttons on a pad device are numbered sequentially, see Tablet
    /// pad button numbers for details.
    pub fn tablet_pad_number_of_buttons, ffi::libinput_device_tablet_pad_get_num_buttons, i32);
    ffi_func!(
    /// Return the number of rings a device with the
    /// `DeviceCapability::TabletPad` capability provides.
    pub fn tablet_pad_number_of_rings, ffi::libinput_device_tablet_pad_get_num_rings, i32);
    ffi_func!(
    /// Return the number of strips a device with the
    /// `DeviceCapability::TabletPad` capability provides.
    pub fn tablet_pad_number_of_strips, ffi::libinput_device_tablet_pad_get_num_strips, i32);
    ffi_func!(
    /// Most devices only provide a single mode group, however devices
    /// such as the Wacom Cintiq 22HD provide two mode groups.
    ///
    /// If multiple mode groups are available, a caller should use
    /// `TabletPadModeGroup::has_button`,
    /// `TabletPadModeGroup::has_ring` and
    /// `TabletPadModeGroup::has_strip()` to associate each button,
    /// ring and strip with the correct mode group.
    pub fn tablet_pad_number_of_mode_groups, ffi::libinput_device_tablet_pad_get_num_mode_groups, i32);

    /// Return the current mode this mode group is in.
    ///
    /// Note that the returned mode is the mode valid as of completing
    /// the last `dispatch`. The returned mode may thus be
    /// different than the mode returned by
    /// `TabletPadEventTrait::mode`.
    ///
    /// For example, if the mode was toggled three times between the
    /// call to `dispatch`, this function returns the third mode but
    /// the events in the event queue will return the modes 1, 2 and
    /// 3, respectively.
    pub fn tablet_pad_get_mode_group(&self, index: u32) -> Option<TabletPadModeGroup> {
        let ptr = unsafe { ffi::libinput_device_tablet_pad_get_mode_group(self.as_raw_mut(), index) };
        if ptr.is_null() {
            None
        } else {
            Some(unsafe { TabletPadModeGroup::from_raw(ptr) })
        }
    }

    /// Return the default pointer acceleration profile for this
    /// pointer device.
    pub fn config_accel_default_profile(&self) -> Option<AccelProfile>
    {
        match unsafe { ffi::libinput_device_config_accel_get_default_profile(self.as_raw_mut()) } {
            ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_NONE => None,
            ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT => Some(AccelProfile::Flat),
            ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE => Some(AccelProfile::Adaptive),
        }
    }

    /// Get the current pointer acceleration profile for this pointer
    /// device.
    pub fn config_accel_profile(&self) -> Option<AccelProfile>
    {
        match unsafe { ffi::libinput_device_config_accel_get_profile(self.as_raw_mut()) } {
            ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_NONE => None,
            ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT => Some(AccelProfile::Flat),
            ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE => Some(AccelProfile::Adaptive),
        }
    }

    /// Returns a bitmask of the configurable acceleration modes
    /// available on this device.
    pub fn config_accel_profiles(&self) -> Vec<AccelProfile>
    {
        let mut profiles = Vec::new();
        let bitmask = unsafe { ffi::libinput_device_config_accel_get_profiles(self.as_raw_mut()) };
        if bitmask & ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT as u32 == bitmask {
            profiles.push(AccelProfile::Flat);
        }
        if bitmask & ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE as u32 == bitmask {
            profiles.push(AccelProfile::Adaptive);
        }
        profiles
    }

    /// Set the pointer acceleration profile of this pointer device to
    /// the given mode.
    pub fn config_accel_set_profile(&mut self, profile: AccelProfile) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_accel_set_profile(self.as_raw_mut(), match profile {
            AccelProfile::Flat => ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT,
            AccelProfile::Adaptive => ffi::libinput_config_accel_profile::LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE,
        }) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    ffi_func!(
    /// Return the default speed setting for this device, normalized
    /// to a range of [-1, 1].
    pub fn config_accel_default_speed, ffi::libinput_device_config_accel_get_default_speed, f64);
    ffi_func!(
    /// Get the current pointer acceleration setting for this pointer
    /// device.
    ///
    /// The returned value is normalized to a range of [-1, 1]. See
    /// `config_accel_set_speed` for details.
    pub fn config_accel_speed, ffi::libinput_device_config_accel_get_speed, f64);

    /// Set the pointer acceleration speed of this pointer device
    /// within a range of [-1, 1], where 0 is the default acceleration
    /// for this device, -1 is the slowest acceleration and 1 is the
    /// maximum acceleration available on this device.
    ///
    /// The actual pointer acceleration mechanism is
    /// implementation-dependent, as is the number of steps available
    /// within the range. libinput picks the semantically closest
    /// acceleration step if the requested value does not match a
    /// discrete setting.
    pub fn config_accel_set_speed(&mut self, speed: f64) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_accel_set_speed(self.as_raw_mut(), speed) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    ffi_func!(
    /// Check if a device uses libinput-internal pointer-acceleration.
    pub fn config_accel_is_available, ffi::libinput_device_config_accel_is_available, bool);

    /// Return the default calibration matrix for this device.
    ///
    /// On most devices, this is the identity matrix. If the udev
    /// property `LIBINPUT_CALIBRATION_MATRIX` is set on the respective u
    /// dev device, that property's value becomes the default matrix,
    /// see [Static device configuration via udev](https://wayland.freedesktop.org/libinput/doc/latest/udev_config.html).
    pub fn config_calibration_default_matrix(&self) -> Option<[f32; 6]> {
        let mut matrix = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        if unsafe { ffi::libinput_device_config_calibration_get_default_matrix(self.as_raw_mut(), matrix.as_mut_ptr()) != 0 } {
            Some(matrix)
        } else {
            None
        }
    }

    /// Return the current calibration matrix for this device.
    pub fn config_calibration_matrix(&self) -> Option<[f32; 6]> {
        let mut matrix = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
        if unsafe { ffi::libinput_device_config_calibration_get_matrix(self.as_raw_mut(), matrix.as_mut_ptr()) != 0 } {
            Some(matrix)
        } else {
            None
        }
    }

    ffi_func!(
    /// Check if the device can be calibrated via a calibration matrix.
    pub fn config_calibration_has_matrix, ffi::libinput_device_config_calibration_has_matrix, bool);

    /// Apply the 3x3 transformation matrix to absolute device
    /// coordinates.
    ///
    /// This matrix has no effect on relative events.
    ///
    /// Given a 6-element array [a, b, c, d, e, f], the matrix is
    /// applied as
    ///
    ///     [ a  b  c ]   [ x ]
    ///     [ d  e  f ] * [ y ]
    ///     [ 0  0  1 ]   [ 1 ]
    ///     # *
    ///
    /// The translation component (c, f) is expected to be normalized
    /// to the device coordinate range. For example, the matrix
    ///
    ///     [ 1 0  1 ]
    ///     [ 0 1 -1 ]
    ///     [ 0 0  1 ]
    ///
    /// moves all coordinates by 1 device-width to the right and 1
    /// device-height up.
    ///
    /// The rotation matrix for rotation around the origin is defined
    /// as
    ///
    ///     [ cos(a) -sin(a) 0 ]
    ///     [ sin(a)  cos(a) 0 ]
    ///     [   0      0     1 ]
    ///
    /// Note that any rotation requires an additional translation
    /// component to translate the rotated coordinates back into the
    /// original device space. The rotation matrixes for 90, 180 and
    /// 270 degrees clockwise are:
    ///
    ///     90 deg cw:              180 deg cw:             270 deg cw:
    ///     [ 0 -1 1]               [ -1  0 1]              [  0 1 0 ]
    ///     [ 1  0 0]               [  0 -1 1]              [ -1 0 1 ]
    ///     [ 0  0 1]               [  0  0 1]              [  0 0 1 ]
    ///
    pub fn config_calibration_set_matrix(&mut self, matrix: [f32; 6]) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_calibration_set_matrix(self.as_raw_mut(), matrix.as_ptr()) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    /// Get the default button click method for this device.
    ///
    /// The button click method defines when to generate
    /// software-emulated buttons, usually on a device that does not
    /// have a specific physical button available.
    pub fn config_click_default_method(&self) -> Option<ClickMethod>
    {
        match unsafe { ffi::libinput_device_config_click_get_default_method(self.as_raw_mut()) } {
            ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_NONE => None,
            ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS => Some(ClickMethod::ButtonAreas),
            ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER => Some(ClickMethod::Clickfinger),
        }
    }

    /// Get the button click method for this device.
    ///
    /// The button click method defines when to generate
    /// software-emulated buttons, usually on a device that does not
    /// have a specific physical button available.
    pub fn config_click_method(&self) -> Option<ClickMethod>
    {
        match unsafe { ffi::libinput_device_config_click_get_method(self.as_raw_mut()) } {
            ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_NONE => None,
            ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS => Some(ClickMethod::ButtonAreas),
            ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER => Some(ClickMethod::Clickfinger),
        }
    }

    /// Check which button click methods a device supports.
    ///
    /// The button click method defines when to generate
    /// software-emulated buttons, usually on a device that does not
    /// have a specific physical button available.
    pub fn config_click_methods(&self) -> Vec<ClickMethod>
    {
        let mut methods = Vec::new();
        let bitmask = unsafe { ffi::libinput_device_config_click_get_methods(self.as_raw_mut()) };
        if bitmask & ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER as u32 == bitmask {
            methods.push(ClickMethod::Clickfinger);
        }
        if bitmask & ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS as u32 == bitmask {
            methods.push(ClickMethod::ButtonAreas);
        }
        methods
    }

    /// Set the button click method for this device.
    ///
    /// The button click method defines when to generate
    /// software-emulated buttons, usually on a device that does not
    /// have a specific physical button available.
    ///
    /// ## Note
    ///
    /// The selected click method may not take effect immediately. The
    /// device may require changing to a neutral state first before
    /// activating the new method.
    pub fn config_click_set_method(&mut self, method: ClickMethod) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_click_set_method(self.as_raw_mut(), match method {
            ClickMethod::ButtonAreas => ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS,
            ClickMethod::Clickfinger => ffi::libinput_config_click_method::LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER,
        }) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    /// Check if the disable-while typing feature is enabled on this
    /// device by default.
    ///
    /// If the device does not support disable-while-typing, this
    /// function returns `false`.
    pub fn config_dwt_default_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_dwt_get_default_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_dwt_state::LIBINPUT_CONFIG_DWT_ENABLED => true,
            ffi::libinput_config_dwt_state::LIBINPUT_CONFIG_DWT_DISABLED => false,
        }
    }

    /// Check if the disable-while typing feature is currently enabled
    /// on this device.
    ///
    /// If the device does not support disable-while-typing, this
    /// function returns `false`.
    pub fn config_dwt_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_dwt_get_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_dwt_state::LIBINPUT_CONFIG_DWT_ENABLED => true,
            ffi::libinput_config_dwt_state::LIBINPUT_CONFIG_DWT_DISABLED => false,
        }
    }

    ffi_func!(
    /// Check if this device supports configurable
    /// disable-while-typing feature.
    ///
    /// This feature is usually available on built-in touchpads and
    /// disables the touchpad while typing. See [Disable-while-typing](https://wayland.freedesktop.org/libinput/doc/latest/palm_detection.html#disable-while-typing)
    /// for details.
    pub fn config_dwt_is_available, ffi::libinput_device_config_dwt_is_available, bool);

    /// Enable or disable the disable-while-typing feature.
    ///
    /// When enabled, the device will be disabled while typing and
    /// for a short period after. See Disable-while-typing for
    /// details.
    ///
    /// ## Note
    ///
    /// Enabling or disabling disable-while-typing may not take
    /// effect immediately.
    pub fn config_dwt_set_enabled(&self, enabled: bool) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_dwt_set_enabled(self.as_raw_mut(), match enabled {
            true => ffi::libinput_config_dwt_state::LIBINPUT_CONFIG_DWT_ENABLED,
            false => ffi::libinput_config_dwt_state::LIBINPUT_CONFIG_DWT_DISABLED,
        }) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    ffi_func!(
    /// Get the current left-handed configuration of the device.
    pub fn config_left_handed, ffi::libinput_device_config_left_handed_get, bool);
    ffi_func!(
    /// Get the default left-handed configuration of the device.
    pub fn config_left_handed_default, ffi::libinput_device_config_left_handed_get_default, bool);
    ffi_func!(
    /// Check if a device has a configuration that supports
    /// left-handed usage.
    pub fn config_left_handed_is_available, ffi::libinput_device_config_left_handed_is_available, bool);

    /// Set the left-handed configuration of the device.
    ///
    /// The exact behavior is device-dependent. On a mouse and most
    /// pointing devices, left and right buttons are swapped but the
    /// middle button is unmodified. On a touchpad, physical buttons
    /// (if present) are swapped. On a clickpad, the top and bottom
    /// software-emulated buttons are swapped where present, the main
    /// area of the touchpad remains a left button. Tapping and
    /// clickfinger behavior is not affected by this setting.
    ///
    /// Changing the left-handed configuration of a device may not
    /// take effect until all buttons have been logically released.
    pub fn config_left_handed_set(&self, enabled: bool) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_left_handed_set(self.as_raw_mut(), enabled as i32) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    /// Check if configurable middle button emulation is enabled by
    /// default on this device.
    ///
    /// See [Middle button emulation](https://wayland.freedesktop.org/libinput/doc/latest/middle_button_emulation.html) for details.
    ///
    /// If the device does not have configurable middle button
    /// emulation, this function returns `false`.
    ///
    /// ## Note
    ///
    /// Some devices provide middle mouse button emulation but do not
    /// allow enabling/disabling that emulation. These devices always
    /// return `false`.
    pub fn config_middle_emulation_default_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_middle_emulation_get_default_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_middle_emulation_state::LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED => true,
            ffi::libinput_config_middle_emulation_state::LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED => false,
        }
    }

    /// Check if configurable middle button emulation is enabled on
    /// this device.
    ///
    /// See [Middle button emulation](https://wayland.freedesktop.org/libinput/doc/latest/middle_button_emulation.html)
    /// for details.
    ///
    /// If the device does not have configurable middle button
    /// emulation, this function returns `false`.
    ///
    /// ## Note
    ///
    /// Some devices provide middle mouse button emulation but do not
    /// allow enabling/disabling that emulation. These devices always
    /// return `false`.
    pub fn config_middle_emulation_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_middle_emulation_get_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_middle_emulation_state::LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED => true,
            ffi::libinput_config_middle_emulation_state::LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED => false,
        }
    }

    ffi_func!(
    /// Check if middle mouse button emulation configuration is
    /// available on this device.
    ///
    /// See [Middle button emulation](https://wayland.freedesktop.org/libinput/doc/latest/middle_button_emulation.html)
    /// for details.
    ///
    /// ## Note
    ///
    /// Some devices provide middle mouse button emulation but do not
    /// allow enabling/disabling that emulation. These devices return
    /// `false` in `config_middle_emulation_is_available`.
    pub fn config_middle_emulation_is_available, ffi::libinput_device_config_middle_emulation_is_available, bool);

    /// Enable or disable middle button emulation on this device.
    ///
    /// When enabled, a simultaneous press of the left and right
    /// button generates a middle mouse button event. Releasing the
    /// buttons generates a middle mouse button release, the left and
    /// right button events are discarded otherwise.
    ///
    /// See [Middle button emulation](https://wayland.freedesktop.org/libinput/doc/latest/middle_button_emulation.html)
    /// for details.
    pub fn config_middle_emulation_set_enabled(&self, enabled: bool) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_middle_emulation_set_enabled(self.as_raw_mut(), match enabled {
            true => ffi::libinput_config_middle_emulation_state::LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED,
            false => ffi::libinput_config_middle_emulation_state::LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED,
        }) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    ffi_func!(
    /// Get the current rotation of a device in degrees clockwise off
    /// the logical neutral position.
    ///
    /// If this device does not support rotation, the return value is
    /// always 0.
    pub fn config_rotation_angle, ffi::libinput_device_config_rotation_get_angle, u32);
    ffi_func!(
    /// Get the default rotation of a device in degrees clockwise off
    /// the logical neutral position.
    ///
    /// If this device does not support rotation, the return value is
    /// always 0.
    pub fn config_rotation_default_angle, ffi::libinput_device_config_rotation_get_default_angle, u32);
    ffi_func!(
    /// Check whether a device can have a custom rotation applied.
    pub fn config_rotation_is_available, ffi::libinput_device_config_rotation_is_available, bool);

    /// Set the rotation of a device in degrees clockwise off the
    /// logical neutral position.
    ///
    /// Any subsequent motion events are adjusted according to the
    /// given angle.
    ///
    /// The angle has to be in the range of [0, 360] degrees,
    /// otherwise this function returns `DeviceConfigError::Invalid`.
    /// If the angle is a multiple of 360 or negative, the caller
    /// must ensure the correct ranging before calling this function.
    ///
    /// libinput guarantees that this function accepts multiples of
    /// 90 degrees. If a value is within the [0, 360] range but not a
    /// multiple of 90 degrees, this function may return
    /// `DeviceConfigError::Invalid` if the underlying device or
    /// implementation does not support finer-grained rotation angles.
    ///
    /// The rotation angle is applied to all motion events emitted by
    /// the device. Thus, rotating the device also changes the angle
    /// required or presented by scrolling, gestures, etc.
    ///
    /// Setting a rotation of 0 degrees on a device that does not
    /// support rotation always succeeds.
    pub fn config_rotation_set_angle(&self, angle: u32) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_rotation_set_angle(self.as_raw_mut(), angle) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    ffi_func!(
    /// Get the button for the `ScrollMethod::OnButtonDown` method
    /// for this device.
    ///
    /// If `ScrollMethod::OnButtonDown` scroll method is not
    /// supported, or no button is set, this function returns 0.
    ///
    /// ## Note
    ///
    /// The return value is independent of the currently selected
    /// scroll-method. For button scrolling to activate, a device
    /// must have the `ScrollMethod::OnButtonDown` method enabled,
    /// and a non-zero button set as scroll button.
    pub fn config_scroll_button, ffi::libinput_device_config_scroll_get_button, u32);
    ffi_func!(
    /// Get the default button for the `ScrollMethod::OnButtonDown`
    /// method for this device.
    ///
    /// If `ScrollMethod::OnButtonDown` scroll method is not
    /// supported, or no default button is set,
    /// this function returns 0.
    pub fn config_scroll_default_button, ffi::libinput_device_config_scroll_get_default_button, u32);

    /// Get the default scroll method for this device.
    ///
    /// The method defines when to generate scroll axis events
    /// instead of pointer motion events.
    pub fn config_scroll_default_method(&self) -> ScrollMethod
    {
        match unsafe { ffi::libinput_device_config_scroll_get_default_method(self.as_raw_mut()) } {
            ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_NO_SCROLL => ScrollMethod::NoScroll,
            ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_2FG => ScrollMethod::TwoFinger,
            ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_EDGE => ScrollMethod::Edge,
            ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN => ScrollMethod::OnButtonDown,
        }
    }

    /// Get the scroll method for this device.
    ///
    /// The method defines when to generate scroll axis events
    /// instead of pointer motion events.
    pub fn config_scroll_method(&self) -> ScrollMethod
    {
        match unsafe { ffi::libinput_device_config_scroll_get_method(self.as_raw_mut()) } {
            ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_NO_SCROLL => ScrollMethod::NoScroll,
            ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_2FG => ScrollMethod::TwoFinger,
            ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_EDGE => ScrollMethod::Edge,
            ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN => ScrollMethod::OnButtonDown,
        }
    }

    /// Check which scroll methods a device supports.
    ///
    /// The method defines when to generate scroll axis events
    /// instead of pointer motion events.
    pub fn config_scroll_methods(&self) -> Vec<ScrollMethod>
    {
        let mut methods = Vec::new();
        let bitmask = unsafe { ffi::libinput_device_config_scroll_get_methods(self.as_raw_mut()) };
        if bitmask & ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_NO_SCROLL as u32 == bitmask {
            methods.push(ScrollMethod::NoScroll);
        }
        if bitmask & ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_2FG as u32 == bitmask {
            methods.push(ScrollMethod::TwoFinger);
        }
        if bitmask & ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_EDGE as u32 == bitmask {
            methods.push(ScrollMethod::Edge);
        }
        if bitmask & ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN as u32 == bitmask {
            methods.push(ScrollMethod::OnButtonDown);
        }
        methods
    }

    /// Set the scroll method for this device.
    ///
    /// The method defines when to generate scroll axis events
    /// instead of pointer motion events.
    ///
    /// ## Note
    ///
    /// Setting `ScrollMethod::OnButtonDown` enables the scroll
    /// method, but scrolling is only activated when the configured
    /// button is held down. If no button is set, i.e.
    /// `config_scroll_button` returns 0, scrolling cannot activate.
    pub fn config_scroll_set_method(&mut self, method: ScrollMethod) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_scroll_set_method(self.as_raw_mut(), match method {
            ScrollMethod::NoScroll => ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_NO_SCROLL,
            ScrollMethod::TwoFinger => ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_2FG,
            ScrollMethod::Edge => ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_EDGE,
            ScrollMethod::OnButtonDown => ffi::libinput_config_scroll_method::LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN,
        }) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    ffi_func!(
    /// Get the default mode for scrolling on this device.
    pub fn config_scroll_default_natural_scroll_enabled, ffi::libinput_device_config_scroll_get_default_natural_scroll_enabled, bool);
    ffi_func!(
    /// Get the current mode for scrolling on this device.
    pub fn config_scroll_natural_scroll_enabled, ffi::libinput_device_config_scroll_get_natural_scroll_enabled, bool);
    ffi_func!(
    /// Return non-zero if the device supports "natural scrolling".
    ///
    /// In traditional scroll mode, the movement of fingers on a
    /// touchpad when scrolling matches the movement of the scroll
    /// bars. When the fingers move down, the scroll bar moves down,
    /// a line of text on the screen moves towards the upper end of
    /// the screen. This also matches scroll wheels on mice (wheel
    /// down, content moves up).
    ///
    /// Natural scrolling is the term coined by Apple for inverted
    /// scrolling. In this mode, the effect of scrolling movement of
    /// fingers on a touchpad resemble physical manipulation of
    /// paper. When the fingers move down, a line of text on the
    /// screen moves down (scrollbars move up). This is the opposite
    /// of scroll wheels on mice.
    ///
    /// A device supporting natural scrolling can be switched between
    /// traditional scroll mode and natural scroll mode.
    pub fn config_scroll_has_natural_scroll, ffi::libinput_device_config_scroll_has_natural_scroll, bool);

    /// Enable or disable natural scrolling on the device.
    pub fn config_scroll_set_natural_scroll_enabled(&mut self, enabled: bool) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_scroll_set_natural_scroll_enabled(self.as_raw_mut(), enabled as i32) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    /// Set the button for the `ScrollMethod::OnButtonDown` method
    /// for this device.
    ///
    /// When the current scroll method is set to
    /// `ScrollMethod::OnButtonDown`, no button press/release events
    /// will be send for the configured button.
    ///
    /// When the configured button is pressed, any motion events
    /// along a scroll-capable axis are turned into scroll axis
    /// events.
    ///
    /// ## Note
    ///
    /// Setting the button does not change the scroll method. To
    /// change the scroll method call `config_scroll_set_method`.
    /// If the button is 0, button scrolling is effectively disabled.
    pub fn config_scroll_set_button(&mut self, button: u32) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_scroll_set_button(self.as_raw_mut(), button) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    /// Get the send-event mode for this device.
    ///
    /// The mode defines when the device processes and sends events
    /// to the caller.
    ///
    /// If a caller enables the bits for multiple modes, some of
    /// which are subsets of another mode libinput may drop the bits
    /// that are subsets. In other words, don't expect
    /// `config_send_events_mode` to always return exactly the same
    /// as passed into `config_send_events_set_mode`.
    pub fn config_send_events_mode(&self) -> Vec<SendEventsMode> {
        let mut methods = Vec::new();
        let bitmask = unsafe { ffi::libinput_device_config_send_events_get_mode(self.as_raw_mut()) };
        if bitmask & ffi::libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_ENABLED as u32 == bitmask {
            methods.push(SendEventsMode::Enabled);
        }
        if bitmask & ffi::libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_DISABLED as u32 == bitmask {
            methods.push(SendEventsMode::Disabled);
        }
        if bitmask & ffi::libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE as u32 == bitmask {
            methods.push(SendEventsMode::DisabledOnExternalMouse);
        }
        methods
    }

    /// Return the possible send-event modes for this device.
    ///
    /// These modes define when a device may process and send events.
    pub fn config_send_events_modes(&self) -> Vec<SendEventsMode> {
        let mut methods = Vec::new();
        let bitmask = unsafe { ffi::libinput_device_config_send_events_get_modes(self.as_raw_mut()) };
        if bitmask & ffi::libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_ENABLED as u32 == bitmask {
            methods.push(SendEventsMode::Enabled);
        }
        if bitmask & ffi::libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_DISABLED as u32 == bitmask {
            methods.push(SendEventsMode::Disabled);
        }
        if bitmask & ffi::libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE as u32 == bitmask {
            methods.push(SendEventsMode::DisabledOnExternalMouse);
        }
        methods
    }

    /// Set the send-event mode for this device.
    ///
    /// The mode defines when the device processes and sends events
    /// to the caller.
    ///
    /// The selected mode may not take effect immediately. Events
    /// already received and processed from this device are
    /// unaffected and will be passed to the caller on the next call
    /// to `<Libinput as Iterator>::next()`.
    ///
    /// If the mode is a mixture of `SendEventsMode`s, the device may
    /// wait for or generate events until it is in a neutral state.
    /// For example, this may include waiting for or generating
    /// button release events.
    ///
    /// If the device is already suspended, this function does
    /// nothing and returns success. Changing the send-event mode on
    /// a device that has been removed is permitted.
    pub fn config_send_events_set_mode(&self, mode: &[SendEventsMode]) -> DeviceConfigResult {
        let mut bitmask = 0u32;
        for flag in mode {
            match *flag {
                SendEventsMode::Enabled => bitmask |= ffi::libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_ENABLED as u32,
                SendEventsMode::Disabled => bitmask |= ffi::libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_DISABLED as u32,                SendEventsMode::DisabledOnExternalMouse => bitmask |= ffi::libinput_config_send_events_mode_LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE as u32,
            }
        }
        match unsafe { ffi::libinput_device_config_send_events_set_mode(self.as_raw_mut(), bitmask) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    /// Get the finger number to button number mapping for
    /// tap-to-click.
    ///
    /// The return value for a device that does not support tapping
    /// is always `TapButtonMap::LeftRightMiddle`.
    ///
    /// This will return `None` for devices
    /// where `config_tap_finger_count` returns 0.
    pub fn config_tap_button_map(&self) -> Option<TapButtonMap> {
        if self.config_tap_finger_count() == 0 {
            None
        } else {
            match unsafe { ffi::libinput_device_config_tap_get_button_map(self.as_raw_mut()) } {
                ffi::libinput_config_tap_button_map::LIBINPUT_CONFIG_TAP_MAP_LRM => Some(TapButtonMap::LeftRightMiddle),
                ffi::libinput_config_tap_button_map::LIBINPUT_CONFIG_TAP_MAP_LMR => Some(TapButtonMap::LeftMiddleRight),
            }
        }
    }

    /// Get the default finger number to button number mapping for
    /// tap-to-click.
    ///
    /// The return value for a device that does not support tapping
    /// is always `TapButtonMap::LeftRightMiddle`.
    ///
    /// This will return `None` for devices
    /// where `config_tap_finger_count` returns 0.
    pub fn config_tap_default_button_map(&self) -> Option<TapButtonMap> {
        if self.config_tap_finger_count() == 0 {
            None
        } else {
            match unsafe { ffi::libinput_device_config_tap_get_default_button_map(self.as_raw_mut()) } {
                ffi::libinput_config_tap_button_map::LIBINPUT_CONFIG_TAP_MAP_LRM => Some(TapButtonMap::LeftRightMiddle),
                ffi::libinput_config_tap_button_map::LIBINPUT_CONFIG_TAP_MAP_LMR => Some(TapButtonMap::LeftMiddleRight),
            }
        }
    }

    /// Return whether tap-and-drag is enabled or disabled by default
    /// on this device.
    pub fn config_tap_default_drag_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_tap_get_default_drag_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_drag_state::LIBINPUT_CONFIG_DRAG_ENABLED => true,
            ffi::libinput_config_drag_state::LIBINPUT_CONFIG_DRAG_DISABLED => false,
        }
    }

    /// Check if drag-lock during tapping is enabled by default on
    /// this device.
    ///
    /// If the device does not support tapping, this function always
    /// returns `false`.
    ///
    /// Drag lock may be enabled by default even when tapping is
    /// disabled by default.
    pub fn config_tap_default_drag_lock_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_tap_get_default_drag_lock_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_drag_lock_state::LIBINPUT_CONFIG_DRAG_LOCK_ENABLED => true,
            ffi::libinput_config_drag_lock_state::LIBINPUT_CONFIG_DRAG_LOCK_DISABLED => false,
        }
    }

    /// Return the default setting for whether tap-to-click is
    /// enabled on this device.
    pub fn config_tap_default_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_tap_get_default_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_tap_state::LIBINPUT_CONFIG_TAP_ENABLED => true,
            ffi::libinput_config_tap_state::LIBINPUT_CONFIG_TAP_DISABLED => false,
        }
    }

    /// Return whether tap-and-drag is enabled or disabled on this
    /// device.
    pub fn config_tap_drag_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_tap_get_drag_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_drag_state::LIBINPUT_CONFIG_DRAG_ENABLED => true,
            ffi::libinput_config_drag_state::LIBINPUT_CONFIG_DRAG_DISABLED => false,
        }
    }

    /// Check if drag-lock during tapping is enabled on this device.
    ///
    /// If the device does not support tapping, this function always
    /// returns `false`.
    ///
    /// Drag lock may be enabled even when tapping is disabled.
    pub fn config_tap_drag_lock_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_tap_get_drag_lock_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_drag_lock_state::LIBINPUT_CONFIG_DRAG_LOCK_ENABLED => true,
            ffi::libinput_config_drag_lock_state::LIBINPUT_CONFIG_DRAG_LOCK_DISABLED => false,
        }
    }

    /// Check if tap-to-click is enabled on this device.
    ///
    /// If the device does not support tapping, this function always
    /// returns `false`.
    pub fn config_tap_enabled(&self) -> bool {
        match unsafe { ffi::libinput_device_config_tap_get_enabled(self.as_raw_mut()) } {
            ffi::libinput_config_tap_state::LIBINPUT_CONFIG_TAP_ENABLED => true,
            ffi::libinput_config_tap_state::LIBINPUT_CONFIG_TAP_DISABLED => false,
        }
    }

    ffi_func!(
    /// Check if the device supports tap-to-click and how many
    /// fingers can be used for tapping.
    ///
    /// See `config_tap_set_enabled` for more information.
    pub fn config_tap_finger_count, ffi::libinput_device_config_tap_get_finger_count, u32);

    /// Set the finger number to button number mapping for
    /// tap-to-click.
    ///
    /// The default mapping on most devices is to have a 1, 2 and 3
    /// finger tap to map to the left, right and middle button,
    /// respectively. A device may permit changing the button mapping
    /// but disallow specific maps. In this case
    /// `DeviceConfigError::Disabled` is returned, the caller is
    /// expected to handle this case correctly.
    ///
    /// Changing the button mapping may not take effect immediately,
    /// the device may wait until it is in a neutral state before
    /// applying any changes.
    ///
    /// The mapping may be changed when tap-to-click is disabled. The
    /// new mapping takes effect when tap-to-click is enabled in the
    /// future.
    ///
    /// ## Note
    ///
    /// This will return `None` for devices where
    /// `config_tap_finger_count` returns 0.
    pub fn config_tap_set_button_map(&mut self, map: TapButtonMap) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_tap_set_button_map(self.as_raw_mut(), match map {
            TapButtonMap::LeftRightMiddle => ffi::libinput_config_tap_button_map::LIBINPUT_CONFIG_TAP_MAP_LRM,
            TapButtonMap::LeftMiddleRight => ffi::libinput_config_tap_button_map::LIBINPUT_CONFIG_TAP_MAP_LMR,
        }) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    /// Enable or disable tap-and-drag on this device.
    ///
    /// When enabled, a single-finger tap immediately followed by a
    /// finger down results in a button down event, subsequent finger
    /// motion thus triggers a drag. The button is released on finger
    /// up.
    /// See [Tap-and-drag](https://wayland.freedesktop.org/libinput/doc/latest/tapping.html#tapndrag)
    /// for more details.
    pub fn config_tap_set_drag_enabled(&mut self, enabled: bool) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_tap_set_drag_enabled(self.as_raw_mut(), match enabled {
            true => ffi::libinput_config_drag_state::LIBINPUT_CONFIG_DRAG_ENABLED,
            false => ffi::libinput_config_drag_state::LIBINPUT_CONFIG_DRAG_DISABLED,
        }) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    /// Enable or disable drag-lock during tapping on this device.
    ///
    /// When enabled, a finger may be lifted and put back on the
    /// touchpad within a timeout and the drag process continues.
    /// When disabled, lifting the finger during a tap-and-drag will
    /// immediately stop the drag.
    /// See [Tap-and-drag](https://wayland.freedesktop.org/libinput/doc/latest/tapping.html#tapndrag)
    /// for details.
    ///
    /// Enabling drag lock on a device that has tapping disabled is
    /// permitted, but has no effect until tapping is enabled.
    pub fn config_tap_set_drag_lock_enabled(&mut self, enabled: bool) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_tap_set_drag_lock_enabled(self.as_raw_mut(), match enabled {
            true => ffi::libinput_config_drag_lock_state::LIBINPUT_CONFIG_DRAG_LOCK_ENABLED,
            false => ffi::libinput_config_drag_lock_state::LIBINPUT_CONFIG_DRAG_LOCK_DISABLED,
        }) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }

    /// Enable or disable tap-to-click on this device, with a default
    /// mapping of 1, 2, 3 finger tap mapping to left, right, middle
    /// click, respectively.
    ///
    /// Tapping is limited by the number of simultaneous touches
    /// supported by the device, see `config_tap_finger_count`.
    pub fn config_tap_set_enabled(&mut self, enabled: bool) -> DeviceConfigResult {
        match unsafe { ffi::libinput_device_config_tap_set_enabled(self.as_raw_mut(), match enabled {
            true => ffi::libinput_config_tap_state::LIBINPUT_CONFIG_TAP_ENABLED,
            false => ffi::libinput_config_tap_state::LIBINPUT_CONFIG_TAP_DISABLED,
        }) } {
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_SUCCESS => Ok(()),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_UNSUPPORTED => Err(DeviceConfigError::Unsupported),
            ffi::libinput_config_status::LIBINPUT_CONFIG_STATUS_INVALID => Err(DeviceConfigError::Invalid),
        }
    }
}
